\documentclass[11pt,fleqn]{amsart}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{proofs}
\usepackage{mathpartir}
\usepackage[color=yellow]{todonotes}

\begin{document}

\title{Flambda2 Validator}
\date{}
\maketitle{}

%% \section{Flambda2 Simplifier}

\section{Flambda2 Core}

%%  Macros for core exps
\newcommand{\expr}{\mathit{exp}}
\newcommand{\var}{\mathit{var}}
\newcommand{\named}{\mathit{named}}
\newcommand{\arms}{\mathit{arms}}
\newcommand{\codeid}{\mathit{id}}
\newcommand{\code}{\mathit{code}}
\newcommand{\setofclo}{P}
\newcommand{\block}{\mathit{block}}
\newcommand{\blockpat}{\mathit{b}}
\newcommand{\simple}{\mathit{simple}}
\newcommand{\prim}{\mathit{prim}}
\newcommand{\staticconsts}{\chi}
\newcommand{\recinfo}{\mathsf{rec\_info}}
\newcommand{\idexpr}{\mathit{id\_exp}}
\newcommand{\simpleexpr}{\mathit{simple\_exp}}
\newcommand{\symb}{\mathit{symbol}}
\newcommand{\const}{\mathit{const}}
\newcommand{\callid}{\kappa}
\newcommand{\direct}{\mathsf{direct}}
\newcommand{\indirect}{\mathsf{indirect}}
\newcommand{\method}{\mathsf{method}}
\newcommand{\ccall}{\mathsf{c\_call}}
\newcommand{\blockconst}[3]{\mathsf{block}(#1,\,#2,\,#3)}
\newcommand{\contid}[1]{\mathsf{cont}\; #1}

\newcommand{\sep}{\; | \;}
\newcommand{\letexp}[3]{\mathsf{let}\; #1 \; = \; #2 \; \mathsf{in} \; #3}
\newcommand{\letcodeexp}[3]{\mathsf{let}\; (\mathsf{code}^{\uparrow} \; #1) \; = \; #2 \; \mathsf{in} \; #3}
\newcommand{\letcloexp}[3]{\mathsf{let}\; (\mathsf{clo} \; #1) \; = \; #2 \; \mathsf{in} \; #3}
\newcommand{\letstaticcloexp}[3]{\mathsf{let}\; (\mathsf{clo}^{\uparrow} \; #1) \; = \; #2 \; \mathsf{in} \; #3}
\newcommand{\letblockexp}[3]{\mathsf{let}\; (\mathsf{block}^{\uparrow} \; #1) \; = \; #2 \; \mathsf{in} \; #3}
\newcommand{\subst}[3]{#1 \; [ #2 \setminus #3 ]}
\newcommand{\letcont}[4]{#1 \; \mathsf{where} \; (\contid{#2}) \; #3 \; = \; #4}
\newcommand{\step}{\longrightarrow}
\newcommand{\applycont}[2]{#1 \; #2}
\newcommand{\apply}[5]{\mathsf{call}(#1) \; \mathsf{with} \; (#2, \, #3, \, #4, \, #5)}
\newcommand{\abst}[2]{\lambda \; #1.\, #2}
\newcommand{\switch}[2]{\mathsf{switch}\; (#1) \; #2}
\newcommand{\args}[1]{\overrightarrow{#1}}
\newcommand{\substchain}[2]{\; [ #1 \setminus #2 ]}
\newcommand{\invalid}{\mathsf{invalid}}
\newcommand{\load}[3]{\mathsf{load}(#1,\,#2,\,#3)}
\newcommand{\makeblock}[3]{\mathsf{make\_block}(#1,\,#2,\,#3)}

\newcommand{\eval}[2]{\langle #1, \, #2\rangle}
\newcommand{\rebind}[3]{#1 \; [ #2 \mapsto #3 ]}

\begin{figure}[ht]
  \footnotesize
  \begin{align*}
    %
    \simple ::=~& \var \sep \symb \sep \const \\
    %
    \named ::=~& \simple \sep \prim \sep P \sep \staticconsts \sep \recinfo \\
    %
    \expr ::=~& \named \sep \letexp{\var}{\expr_1}{\expr_2} \sep \letcloexp{\mathcal{K}}{\setofclo}{\expr}\\
    & \sep \letcodeexp{\codeid}{\code}{\expr} \sep \letstaticcloexp{\mathcal{K}^{\uparrow}}{\setofclo}{\expr} \\
    & \sep \letblockexp{\blockpat}{\block}{\expr} \sep \letcont{\expr_1}{k}{\args{\expr}}{\expr_2} \\
    & \sep \apply{\callid}{\expr_{\rho}}{res_k}{exn_k}{\args{\expr}} \sep \applycont{\expr_1}{\args{\expr_2}} \\
    & \sep \abst{(res_k,\, exn_k,\, \args{\expr})}{\expr_b}\\
    & \sep \switch{\expr_1}{\arms} \sep \invalid \\
    %
    \code ::=~& \abst{(\rho,\, res_k,\,exn_k\, \args{\expr})}{\expr_b} \\
    %
    x_k ::=~& \contid{k} \sep \abst{\args{\expr}}{\expr_b} \\
    %
    \mathcal{K} ::=~& \var \; list \\
    %
    \mathcal{K}^{\uparrow} ::=~& (\mathit{slot}^{f} \ast \symb) \; \mathit{map} \\
    %
    P ::=~& \{ \mathsf{fns} : (\mathit{slot}^{f} \ast \, \idexpr ) \; \mathit{map} ; \;
    \mathsf{vals} : (\mathit{slot}^{v} \ast \simpleexpr) \; \mathit{map} \}\\
    %
    \idexpr ::=~& \codeid \sep \expr \\
    %
    \simpleexpr ::=~& \simple \sep \expr \\
    %
    \callid ::=~& \direct \; \codeid \sep \indirect \sep \method \sep \ccall \\
    %
    \staticconsts ::=~& P \sep \blockconst{\mathit{tag}}{\mathit{mut}}{\args{\expr}} \sep \cdots \\
    %
    \prim ::=~& \load{\mathit{kind}}{\mathit{mut}}{\expr_b} \sep \makeblock{\mathit{kind}}{\mathit{mut}}{\args{\expr}} \\
    & \sep \pi_{v} \; (\mathit{slot}^{f}) \sep \pi_{f_1} \; (\mathit{slot}^{f_2}) \sep \cdots
  \end{align*}
  \caption{Flambda2 Core Syntax (Abbreviated.) }
  \label{fig:syntax}
\end{figure}

\subsection{Block-based primitives}
Blocks correspond to OCaml blocks, which are the word-aligned chunks of memory allocated for representing values\footnote{For more, see \url{https://dev.realworldocaml.org/runtime-memory-layout.html}. }.
Each block has a tag, corresponding to the constructors/field index of a value (e.g. \textsf{tag0} is the first constructor of an ADT).
The mutability field corresponds to whether the block represents a reference cell.
The block-related primitives allows the representation of structs, tuples, lists, and arrays.
We plan to support the block-related primitives (\textsf{load} from a block and \textsf{make\_block}) except those related to floating-point valued arrays.

\section{Reduction strategy}

\begin{figure}[h!]
\footnotesize
\begin{mathpar}
  \inferrule
      [\footnotesize Let-$\beta$]
      {}
      {\letexp{x}{v}{e} \step \subst{e}{x}{v}}

  \inferrule
      [\footnotesize LetL]
      {e_1 \step e_1'}
      {\letexp{x}{e_1}{e_2} \step \letexp{x}{e_1'}{e_2}}

  \inferrule
      [\footnotesize LetR]
      {e_2 \step e_2'}
      {\letexp{x}{N}{e_2} \step \letexp{x}{N}{e_2'}}

  \inferrule
      [\footnotesize LetClo-$\beta$]
      {x = \mathcal{K}[i]}
      {\letexp{(\mathsf{clo} \; \mathcal{K})}{P}{e} \step \subst{e}{x}{(\pi_1 \; P[i], P)}}

  \inferrule
      [\footnotesize LetStaticClo-$\beta$]
      {x \in \mathcal{K}^{\uparrow}}
      {\letexp{(\mathsf{clo}^{\uparrow} \; \mathcal{K}^{\uparrow})}{P}{e} \step \subst{e}{x}{(x, P)}}

  \inferrule
      [\footnotesize LetCode-$\beta$]
      {}
      {\letcodeexp{f\; (x, \, \rho,\, res_k, \, exn_k)}{e_1}{e_2} \step \subst{e_2}{f}{\lambda (x, \, \rho,\, res_k,\, exn_k). e_1}}

  %% \inferrule
  %%     [\footnotesize LetCodeDeleted]
  %%     {}
  %%     {\letcodeexp{x}{\mathsf{Deleted}}{e} \step e}

  %% \inferrule
  %%     [\footnotesize LetCodeNewer]
  %%     {}
  %%     {\letcodeexp{(\mathsf{newer\_of} \; x) \; x'}{e_1}{e_2} \step
  %%         \letcodeexp{x}{\subst{e_1}{x'}{x}}{\subst{e_2}{x'}{x}}}

  %% IY: This rule is not great because the lifting of statics is not uniform:
  %% we don't want to implement this, the reasoning is too finnicky
  %% \inferrule
  %%     [\footnotesize LetStaticClo]
  %%     {e_2 \step e_2'}
  %%     {\letcodeexp{\mathcal{K}^{\uparrow}}{e_1}{e_2} \step \letcodeexp{\mathcal{K}^{\uparrow}}{e_1}{e_2'}}

  %% \inferrule
  %%     [\footnotesize LetClo]
  %%     {}
  %%     {\letcodeexp{\mathcal{K}}{e_1}{e_2} \step \letcodeexp{\mathcal{K}^{\uparrow}}{e_1^{\uparrow}}{\subst{e_2}{\mathcal{K}}{\mathcal{K}^{\uparrow}}}}

  %% \inferrule
  %%     [\footnotesize LetCode]
  %%     {e_2 \step e_2'}
  %%     {\letcodeexp{x}{N}{e_2} \step \letcodeexp{x}{N}{e_2'}}

  \inferrule
      [\footnotesize LetCont-$\beta$]
      {}
      {\letcont{e_1}{k}{\args{args}}{e_2} \step \subst{e_1}{k}{\abst{\args{args}}{e_2}}}

  \inferrule
      [\footnotesize ClosureVal]
      {}
      {\letcloexp{\mathcal{K}}{([v_{\mathsf{val}} \mapsto \idexpr_v]; P)}{e} \step
        \letcloexp{\mathcal{K}}{\subst{P}{\pi^\rho_{\mathsf{val(v)}}}{\idexpr_v}}{e}}

  \inferrule
      [ClosureFn]
      {K[i] = \mathbf{g} \\ P[i]  = (g_{\mathsf{fn}}, \expr_g)}
      {\letcloexp{(\mathbf{f}; \mathcal{K})}{([f_{\mathsf{fn}} \mapsto \abst{\rho, \, res_k,\,exn_k,\,\args{\expr}}{e_1}] ; P)}{e_2}
        \step
      }\vspace{-1em}\\
      \letcloexp{(\mathbf{f}; \mathcal{K})}{([f_{\mathsf{fn}} \mapsto
          \subst{\abst{\, res_k,\,exn_k,\,\args{\expr}}{e_1}}
                {\pi^\rho_{\mathsf{fn} (f_{\mathsf{fn}} \rightarrow g_{\mathsf{fn}})}}
                {g_{\mathsf{fn}}}
        ] ; P)}{e_2}\\

  \inferrule
      [ClosureFnStatic]
      {}
      {\letstaticcloexp{([f_{\mathsf{fn}} \mapsto \mathbf{f}]; \mathcal{K})}{P}{e_2}
        \step
        \letstaticcloexp{([f_{\mathsf{fn}} \mapsto \mathbf{f}]; \mathcal{K})}{\subst{P}{\mathbf{f}}{f_{\mathsf{fn}}}}{e_2}
      }

  \inferrule
      [\footnotesize ApplyContR]
      {\args{args} \step \args{args}'}
      {\applycont{v}{\args{args}} \step \applycont{v}{\args{args}'}}

  \inferrule
      [\footnotesize ApplyContL]
      {k \step k'}
      {\applycont{k}{\args{args}} \step \applycont{k'}{\args{args}}}


  \inferrule
      [\footnotesize ApplyCont-$\beta$]
      {}
      {\applycont{(\abst{x}{e})}{v} \step \subst{e}{x}{v}}

  \inferrule
      [\footnotesize ApplyR]
      {\args{args} \step \args{args}'}
      {\apply{e}{\rho}{res_k}{exn_k}{\args{args}} \step \apply{e}{\rho}{res_k}{exn_k}{\args{args}'}}

  \inferrule
      [\footnotesize ApplyL]
      {e \step e'}
      {\apply{e}{\rho}{res_k}{exn_k}{\args{args}} \step \apply{e'}{\rho}{res_k}{exn_k}{\args{args}}}

  \inferrule
      [\footnotesize Apply-$\beta$]
      {}
      {\apply{\direct \; \abst{(\rho, \, res_k,\, exn_k,\, \args{\expr})}{\expr_f}}{\rho'}{res_k'}{exn_k'}{\args{v}}
       \step
      }\vspace{-1em}\\
      \subst{\expr_f}{\rho}{\rho'}\substchain{res_k}{res_k'}\substchain{exn_k}{exn_k'}\substchain{\args{\expr}}{\args{v}}\\

  \inferrule
      [\footnotesize Switch]
      {e \step e'}
      {\switch{e}{arms} \step \switch{e'}{arms}}

  \inferrule
      [\footnotesize Switch-$\beta$]
      {}
      {\switch{v}{[x \mapsto e]} \step \subst{e}{x}{v}}

      \overrightarrow{args} \step \overrightarrow{args}' := \forall a, a \in \overrightarrow{args}. \exists a', a \step^\ast a' \land a \in \overrightarrow{args}'
\end{mathpar}
\caption{Evaluation Rules for Flambda2 Core}
\label{fig:reduction}
\end{figure}

\begin{figure}[h!]
\footnotesize
\begin{flalign*}
  \mathbf{Environments}\\
  r ::=~& () \sep (r_1, \, r_2, \,\cdots) \sep \pi_i \; r \sep \langle \rho ,\, \lambda P \, k_r \, k_e \, x.e\rangle \\
  c ::=~& \langle \rho, \, \lambda x.e \rangle \\
  \rho ::=~& \bullet \sep \rho, \, x \mapsto r \sep \rho, \, k \mapsto c \sep \rho, \, X \mapsto K \sep \rho, \, X^{\uparrow} \mapsto K\\
\end{flalign*}
\begin{flalign*}
  \mathbf{Evaluation \; Rules}\\
\end{flalign*}\vspace{-2em}
\begin{mathpar}\footnotesize
  \inferrule
      [\footnotesize Let-$\beta$]
      {}
      {\eval{\letexp{x}{v}{e}}{\rho} \step \eval{e}{\rebind{\rho}{x}{v}}}

  \inferrule
      [\footnotesize LetL]
      {\eval{e_1}{\rho} \step \eval{e_1'}{\rho'}}
      {\eval{\letexp{x}{e_1}{e_2}}{\rho} \step \eval{\letexp{x}{e_1'}{e_2}}{\rho'}}

  \inferrule
      [\footnotesize LetClo-$\beta$]
      {}
      {\eval{\letcloexp{X}{K}{e}}{\rho}
          \step \eval{e}{\rebind{\rho}{X}{K}}}

  \inferrule
      [\footnotesize LetStaticClo-$\beta$]
      {}
      {\eval{\letstaticcloexp{X^{\uparrow}}{K}{e}}{\rho}
        \step \eval{e}{\rebind{\rho}{X^{\uparrow}}{K}}}

  \inferrule
      [\footnotesize LetCode-$\beta$]
      {}
      {\eval{\letcodeexp{\codeid}{\lambda P \; k_r \; k_e \; x. e_1}{e_2}}{\rho}
        \step \eval{e}{\rebind{\rho}{\codeid}{\langle \rho, \lambda P \; k_r \; k_e \; x.e_1 \rangle}}}

  \inferrule
      [\footnotesize LetCont-$\beta$]
      {}
      {\eval{\letcont{e_1}{k}{\args{args}}{e_2}}{\rho} \step
        \eval{e_1}{\rebind{\rho}{k}{\langle \rho, \, \abst{\args{args}}{e_2} \rangle }}}


  \inferrule
      [\footnotesize ApplyContR]
      {\eval{\args{args}}{\rho} \step \eval{\args{args}'}{\rho'}}
      {\eval{\applycont{v}{\args{args}}}{\rho} \step \eval{\applycont{v}{\args{args}'}}{\rho'}}

  \inferrule
      [\footnotesize ApplyContL]
      {\eval{k}{\rho} \step \eval{k'}{\rho'}}
      {\eval{\applycont{k}{\args{args}}}{\rho} \step
        \eval{\applycont{k'}{\args{args}}}{\rho'}}

  \inferrule
      [\footnotesize ApplyCont-$\beta$]
      {\rho(k) = \langle\rho', \, \abst{x}{e}\rangle}
      {\eval{\applycont{k}{v}}{\rho} \step \eval{\subst{e}{x}{v}}{\rho'}}

  \inferrule
      [\footnotesize ApplyR]
      {\eval{\args{args}}{\rho} \step \eval{\args{args}'}{\rho'}}
      {\eval{\apply{\callid}{\expr_\rho}{res_k}{exn_k}{\args{args}}}{\rho} \step
        \eval{\apply{\callid}{\expr_\rho}{res_k}{exn_k}{\args{args}'}}{\rho'}}

  \inferrule
      [\footnotesize ApplyL]
      {\eval{\expr_\rho}{\rho} \step \eval{\expr_\rho'}{\rho'}}
      {\eval{\apply{\callid}{\expr_\rho}{res_k}{exn_k}{\args{args}}}{\rho} \step
        \eval{\apply{\callid}{\expr_\rho'}{res_k}{exn_k}{\args{args}}}{\rho'}}

  \inferrule
      [\footnotesize Apply-$\beta$]
      {\rho(\codeid) = \langle \rho'', \, \lambda P \; k_r \; k_e \; x.e\rangle}
      {\eval{\apply{\direct \; \codeid}{P'}{res_k}{exn_k}{\args{v}}}{\rho}
        \step
        \langle \subst{e}{P}{P'}\substchain{k_r}{res_k}\substchain{k_e}{exn_k}\substchain{x}{\args{v}},\,
        \rho''\rangle}

  \inferrule
      [\footnotesize Switch]
      {\eval{e}{\rho} \step \eval{e'}{\rho'}}
      {\eval{\switch{e}{arms}}{\rho} \step \eval{\switch{e'}{arms}}{\rho'}}

  \inferrule
      [\footnotesize Switch-$\beta$]
      {}
      {\eval{\switch{v}{\{x \mapsto e\}}}{\rho} \step \eval{\subst{e}{x}{v}}{\rho}}

      \overrightarrow{args} \step \overrightarrow{args}' := \forall a, a \in \overrightarrow{args}. \exists a', a \step^\ast a' \land a \in \overrightarrow{args}'
\end{mathpar}
\caption{Evaluation Rules for Flambda2 Core (with environments)}
\end{figure}

This language has a call-by-value style reduction strategy, as shown in Figure \ref{fig:reduction}.
Notice the unusual [LetR] rule---the expression $N$ refers to an expression in
the normal form, which may refer to a normalized effectful expression.
This rule is \textit{not} analogous to the [ApplyContR] rule, since the
lambda abstraction is always implicit in let expressions, ensuring that the
``lefthand-side'' of the application is always a value. This is necessary
because for the case of several effectful expressions (such as a print
statement), inlining the occurence of the expression multiple times will be
behaviorally different from the original expression.

The [Apply-$\beta$] rule describes the case when the callee is a lambda
expression, and the argument is fully evaluated.
The expression is beta-reduced, then the resulting value get passed on as an
argument to either the return or exception continuation, depending on whether
or not the expression throws an exception.


\section{Rewrite Rules}
\begin{mathpar}
  \footnotesize
  \inferrule
      [FlattenMatch]
      {}
      {\switch{\switch{e_1}{[A \mapsto e_2 : B | .. ]}}{[B \mapsto e_2' | .. ]} \step \switch{e_1}{[A \mapsto \subst{e_2'}{B}{e_2} | .. ]}}
\end{mathpar}

\section{Features}

A wishlist of desirable inlining/semantic features to support for the validator.

\subsection{Inlining}
\begin{itemize}
\item function calls
\item recursive functions
\item inlining (direct calls, within same function)
\item cross-module inlining
\item low-priority: locals
\end{itemize}

\subsection{Semantics}
\begin{itemize}
\item mutable state
\item exceptions
\item effects (printing, etc.)
\item external calls
\end{itemize}

\subsection{Primitives evaluation}
\begin{itemize}
\item arithmetic evaluation: commutative and associative laws for arithmetic?
  It is likely that the commutative/associative laws are not necessary for the simplifier
\end{itemize}
TODO: Refactor [simplify\_primitive].

\end{document}
