\documentclass[11pt,fleqn]{amsart}
\usepackage{amssymb}
\usepackage{proofs}
\usepackage{mathpartir}
\usepackage[color=yellow]{todonotes}



\begin{document}

\title{Validator for Flambda2 Simplifier}
\date{}
\maketitle{}

%% \section{Flambda2 Simplifier}

\section{Flambda2 Core}

%%  Macros for core exps
\newcommand{\expr}{\mathit{exp}}
\newcommand{\var}{\mathit{var}}
\newcommand{\named}{\mathit{named}}
\newcommand{\arms}{\mathit{arms}}
\newcommand{\codeid}{\mathit{id}}
\newcommand{\code}{\mathit{code}}
\newcommand{\setofclo}{P}
\newcommand{\block}{\mathit{block}}
\newcommand{\blockpat}{\mathit{b}}
\newcommand{\simple}{\mathit{simple}}
\newcommand{\prim}{\mathit{prim}}
\newcommand{\staticconsts}{\chi}
\newcommand{\recinfo}{\mathsf{rec\_info}}
\newcommand{\idexpr}{\mathit{id\_exp}}
\newcommand{\symb}{\mathit{symbol}}
\newcommand{\const}{\mathit{const}}
\newcommand{\callid}{\kappa}
\newcommand{\direct}{\mathsf{direct}}
\newcommand{\indirect}{\mathsf{indirect}}
\newcommand{\method}{\mathsf{method}}
\newcommand{\ccall}{\mathsf{c\_call}}
\newcommand{\blockconst}[3]{\mathsf{block}(#1,\,#2,\,#3)}

\newcommand{\sep}{\; | \;}
\newcommand{\letexp}[3]{\mathsf{let}\; #1 \; = \; #2 \; \mathsf{in} \; #3}
\newcommand{\letcodeexp}[3]{\mathsf{let}\; (\mathsf{code}^{\uparrow} \; #1) \; = \; #2 \; \mathsf{in} \; #3}
\newcommand{\letcloexp}[3]{\mathsf{let}\; (\mathsf{clo} \; #1) \; = \; #2 \; \mathsf{in} \; #3}
\newcommand{\letstaticcloexp}[3]{\mathsf{let}\; (\mathsf{clo}^{\uparrow} \; #1) \; = \; #2 \; \mathsf{in} \; #3}
\newcommand{\letblockexp}[3]{\mathsf{let}\; (\mathsf{block}^{\uparrow} \; #1) \; = \; #2 \; \mathsf{in} \; #3}
\newcommand{\subst}[3]{#1 \; [ #2 \setminus #3 ]}
\newcommand{\letcont}[4]{#1 \; \mathsf{where} \; #2 \; #3 \; = \; #4}
\newcommand{\step}{\longrightarrow}
\newcommand{\applycont}[2]{#1 \; #2}
\newcommand{\apply}[5]{\mathsf{call}(#1) \; \mathsf{with} \; (#2, \, #3, \, #4, \, #5)}
\newcommand{\abst}[2]{\lambda \; #1.\, #2}
\newcommand{\switch}[2]{\mathsf{switch}\; (#1) \; #2}
\newcommand{\args}[1]{\overrightarrow{#1}}
\newcommand{\substchain}[2]{\; [ #1 \setminus #2 ]}
\newcommand{\invalid}{\mathsf{invalid}}
\newcommand{\load}[3]{\mathsf{load}(#1,\,#2,\,#3)}
\newcommand{\makeblock}[3]{\mathsf{make\_block}(#1,\,#2,\,#3)}

\begin{figure}[ht]
  \begin{align*}
    %
    \simple ::=~& \var \sep \symb \sep \const \\
    %
    \named ::=~& \simple \sep \prim \sep P \sep \staticconsts \sep \recinfo \\
    %
    \expr ::=~& \named \sep \letexp{\var}{\expr_1}{\expr_2} \sep \letcloexp{\mathcal{K}}{\setofclo}{\expr}\\
    & \sep \letcodeexp{\codeid}{\code}{\expr} \sep \letstaticcloexp{\mathcal{K}}{\setofclo}{\expr} \\
    & \sep \letblockexp{\blockpat}{\block}{\expr} \sep \letcont{\expr_1}{k}{x}{\expr_2} \\
    & \sep \apply{\callid}{\expr_{\rho}}{res_k}{exn_k}{\args{\expr}} \sep \applycont{\expr_1}{\args{\expr_2}} \\
    & \sep \switch{\expr_1}{\arms} \sep \invalid \\
    %
    P ::=~& \{ \mathsf{fns} : (\mathit{slot}^{f} \ast \, \idexpr ) \; \mathit{map} ; \;
    \mathsf{vals} : (\mathit{slot}^{v} \ast \simple) \; \mathit{map} \}\\
    %
    \idexpr ::=~& \codeid \sep \expr \\
    %
    \callid ::=~& \direct \; \codeid \sep \indirect \sep \method \sep \ccall \\
    %
    \staticconsts ::=~& P \sep \blockconst{\mathit{tag}}{\mathit{mut}}{\args{\expr}} \sep \cdots \\
    %
    \prim ::=~& \load{\mathit{kind}}{\mathit{mut}}{\expr_b} \sep \makeblock{\mathit{kind}}{\mathit{mut}}{\args{\expr}} \\
    & \sep \pi_{v} \; (\mathit{slot}^{f}) \sep \pi_{f_1} \; (\mathit{slot}^{f_2}) \sep \cdots
  \end{align*}
  \caption{Flambda2 Core Syntax (Abbreviated.) }
  \label{fig:syntax}
\end{figure}



\section{Reduction strategy}



This language has a call-by-value style reduction strategy.
Notice the unusual [LetR] rule---the expression $N$ refers to an expression in
the normal form, which may refer to a normalized effectful expression.
This rule is \textit{not} analogous to the [ApplyContR] rule, since the
lambda abstraction is always implicit in let expressions, ensuring that the
``lefthand-side'' of the application is always a value. This is necessary
because for the case of several effectful expressions (such as a print
statement), inlining the occurence of the expression multiple times will be
behaviorally different from the original expression.

The [Apply-$\beta$] rule describes the case when the callee is a lambda
expression, and the argument is fully evaluated.
The expression is beta-reduced, then the resulting value get passed on as an
argument to either the return or exception continuation, depending on whether
or not the expression throws an exception.

\begin{mathpar}\footnotesize
  \inferrule
      [\footnotesize Let-$\beta$]
      {}
      {\letexp{x}{v}{e} \step \subst{e}{x}{v}}

  \inferrule
      [\footnotesize LetL]
      {e_1 \step e_1'}
      {\letexp{x}{e_1}{e_2} \step \letexp{x}{e_1'}{e_2}}

  \inferrule
      [\footnotesize LetR]
      {e_2 \step e_2'}
      {\letexp{x}{N}{e_2} \step \letexp{x}{N}{e_2'}}

  \inferrule
      [\footnotesize LetClo-$\beta$]
      {}
      {\forall x \; i, x = X[i], \,
        \letexp{(\mathsf{clo} \; X)}{K}{e} \step \subst{e}{x}{(\pi_1 \; K[i], K)}}

  \inferrule
      [\footnotesize LetStaticClo-$\beta$]
      {}
      {\forall x, x \in X^{\uparrow}, \,
        \letexp{(\mathsf{clo} \; X^{\uparrow})}{K}{e} \step \subst{e}{x}{(x, K)}}

  \inferrule
      [\footnotesize LetCode-$\beta$]
      {}
      {\letcodeexp{f\; (x, \, \rho,\, res_k, \, exn_k)}{e_1}{e_2} \step \subst{e_2}{f}{\lambda (x, \, \rho,\, res_k,\, exn_k)}. e_1}

  %% \inferrule
  %%     [\footnotesize LetCodeDeleted]
  %%     {}
  %%     {\letcodeexp{x}{\mathsf{Deleted}}{e} \step e}

  %% \inferrule
  %%     [\footnotesize LetCodeNewer]
  %%     {}
  %%     {\letcodeexp{(\mathsf{newer\_of} \; x) \; x'}{e_1}{e_2} \step
  %%         \letcodeexp{x}{\subst{e_1}{x'}{x}}{\subst{e_2}{x'}{x}}}

  %% IY: This rule is not great because the lifting of statics is not uniform:
  %% we don't want to implement this, the reasoning is too finnicky
  %% \inferrule
  %%     [\footnotesize LetStaticClo]
  %%     {e_2 \step e_2'}
  %%     {\letcodeexp{\mathcal{K}^{\uparrow}}{e_1}{e_2} \step \letcodeexp{\mathcal{K}^{\uparrow}}{e_1}{e_2'}}

  %% \inferrule
  %%     [\footnotesize LetClo]
  %%     {}
  %%     {\letcodeexp{\mathcal{K}}{e_1}{e_2} \step \letcodeexp{\mathcal{K}^{\uparrow}}{e_1^{\uparrow}}{\subst{e_2}{\mathcal{K}}{\mathcal{K}^{\uparrow}}}}

  %% \inferrule
  %%     [\footnotesize LetCode]
  %%     {e_2 \step e_2'}
  %%     {\letcodeexp{x}{N}{e_2} \step \letcodeexp{x}{N}{e_2'}}

  \inferrule
      [\footnotesize LetCont-$\beta$]
      {}
      {\letcont{e_1}{k}{\args{args}}{e_2} \step \subst{e_1}{k}{\abst{\args{args}}{e_2}}}


  \inferrule
      [\footnotesize ApplyContR]
      {\args{args} \step \args{args}'}
      {\applycont{v}{\args{args}} \step \applycont{v}{\args{args}'}}

  \inferrule
      [\footnotesize ApplyContL]
      {k \step k'}
      {\applycont{k}{\args{args}} \step \applycont{k'}{\args{args}}}


  \inferrule
      [\footnotesize ApplyCont-$\beta$]
      {}
      {\applycont{(\abst{x}{e})}{v} \step \subst{e}{x}{v}}

  \inferrule
      [\footnotesize ApplyR]
      {\args{args} \step \args{args}'}
      {\apply{e}{\rho}{res_k}{exn_k}{\args{args}} \step \apply{e}{\rho}{res_k}{exn_k}{\args{args}'}}

  \inferrule
      [\footnotesize ApplyL]
      {e \step e'}
      {\apply{e}{\rho}{res_k}{exn_k}{\args{args}} \step \apply{e'}{\rho}{res_k}{exn_k}{\args{args}}}

  \inferrule
      [\footnotesize Apply-$\beta$]
      {}
      {\apply{\mathsf{direct}(\abst{(x, \, \rho, \, res_k, \, exn_k)}{e})}{K}{\args{v}}{k_r}{k_e}
        \step \subst{e}{\rho}{K}\substchain{x}{\args{v}}\substchain{res_k}{k_r}\substchain{exn_k}{k_e} }

  \inferrule
      [\footnotesize Switch]
      {e \step e'}
      {\switch{e}{arms} \step \switch{e'}{arms}}

  \inferrule
      [\footnotesize Switch-$\beta$]
      {}
      {\switch{v}{[x \mapsto e]} \step \subst{e}{x}{v}}

      \overrightarrow{args} \step \overrightarrow{args}' := \forall a, a \in \overrightarrow{args}. \exists a', a \step^\ast a' \land a \in \overrightarrow{args}'
\end{mathpar}

\section{Rewrite Rules}

\begin{mathpar}
  \inferrule
      [FlattenMatch]
      {}
      {\switch{\switch{e_1}{[A \mapsto e_2 : B | .. ]}}{[B \mapsto e_2' | .. ]} \step \switch{e_1}{[A \mapsto \subst{e_2'}{B}{e_2} | .. ]}}
\end{mathpar}


\section{Features}

A wishlist of desirable inlining/semantic features to support for the validator.

\subsection{Inlining}
\begin{itemize}
\item function calls
\item recursive functions
\item inlining (direct calls, within same function)
\item cross-module inlining
\item low-priority: locals
\end{itemize}

\subsection{Semantics}
\begin{itemize}
\item mutable state
\item exceptions
\item effects (printing, etc.)
\item external calls
\end{itemize}

\subsection{Primitives evaluation}
\begin{itemize}
\item arithmetic evaluation: commutative and associative laws for arithmetic?
  It is likely that the commutative/associative laws are not necessary for the simplifier
\item block-based primitives (makeblock, loading from block)
  The blocks have a tag, corresponding to the constructors (i.e. tag0 is the first constructor)
  values either are immediate tags or blocks
  Mutability corresponds to reference cells

  Being able to treat the block-related primitives will resolve supporting the structures below
  (except for arrays, which have a tricky case involving storing floating-point values.
  See floating-point valued array optimization)
\end{itemize}
TODO: Refactor [simplify\_primitive].

\subsection{Supported structures}
\begin{itemize}
\item structs
\item tuples
\item lists
\item arrays
\end{itemize}

\end{document}
