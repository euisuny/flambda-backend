let $camlTests13__first_const65 = Block 0 () in
let code size(1)
      `anon-fn[:22,44--59]_2`
        (param : imm tagged)
        my_closure my_region my_depth
        -> k * k1
        : variant =
  cont k (0)
in
let code size(1)
      `anon-fn[:22,31--43]_3`
        (x)
        my_closure my_region my_depth
        -> k * k1 =
  cont k (x)
in
let code size(27)
      `anon-fn[:19,2--118]_1`
        (param : imm tagged)
        my_closure my_region my_depth
        -> k * k1 =
  let map_foo =
    %project_value_slot
      `anon-fn[:19,2--118]`.map_foo my_closure
  in
  let i =
    %project_value_slot
      `anon-fn[:19,2--118]`.i my_closure
  in
  let j = i + 3 in
  (let ignore = %Opaque j in
   cont k2 (0))
    where k2 (sequence) =
      let `anon-fn[:22,44--59]` =
        closure
          `anon-fn[:22,44--59]_2`
          @`anon-fn[:22,44--59]`
      in
      let `anon-fn[:22,31--43]` =
        closure
          `anon-fn[:22,31--43]_3`
          @`anon-fn[:22,31--43]`
      in
      apply inlined(never)
        map_foo
          (`anon-fn[:22,31--43]`,
           `anon-fn[:22,44--59]`,
           0)
          -> k * k1
in
let code inline(always) size(37)
      bar_0 (i : imm tagged, map_foo) my_closure my_region my_depth -> k * k1 =
  let `anon-fn[:19,2--118]` =
    closure
      `anon-fn[:19,2--118]_1`
      @`anon-fn[:19,2--118]`
  with { i = i; map_foo = map_foo }
  in
  cont k
         (`anon-fn[:19,2--118]`)
in
let code size(1)
      `anon-fn[:33,15--28]_5`
        (param : imm tagged)
        my_closure my_region my_depth
        -> k * k1
        : variant =
  cont k (0)
in
let code rec size(70)
      map_foo_4 (f, seq, param : imm tagged)
        my_closure my_region my_depth
        -> k * k1
        : variant =
  let next_depth = rec_info (succ my_depth) in
  let bar = %project_value_slot map_foo.bar my_closure in
  apply seq (0) -> k2 * k1
    where k2 (`*match*`) =
      let prim = %is_int `*match*` in
      let Pisint = %Tag_imm prim in
      ((let untagged = %untag_imm Pisint in
        switch untagged
          | 0 -> k2
          | 1 -> k (0))
         where k2 =
           ((let Popaque = %Opaque 0 in
             (let untagged = %untag_imm Popaque in
              switch untagged
                | 0 -> k3
                | 1 -> k4)
               where k4 =
                 apply direct(bar_0)
                   bar
                     (10, my_closure ~ depth my_depth -> next_depth)
                     -> k2 * k1
               where k3 =
                 apply direct(bar_0)
                   bar
                     (20, my_closure ~ depth my_depth -> next_depth)
                     -> k2 * k1)
              where k2 (g) =
                (apply inlined(always) g (0) -> k2 * k1
                   where k2 (g_result : variant) =
                     ((let ignore = %Opaque g_result in
                       cont k2 (0))
                        where k2 (sequence) =
                          let `anon-fn[:33,15--28]` =
                            closure
                              `anon-fn[:33,15--28]_5`
                              @`anon-fn[:33,15--28]`
                          in
                          ((let Pfield = %block_load (`*match*`, 0) in
                            apply f (Pfield) -> k2 * k1)
                             where k2 (apply_result) =
                               let Pmakeblock =
                                 %Block 0
                                   (apply_result,
                                    `anon-fn[:33,15--28]`)
                               in
                               cont k (Pmakeblock))))))
in
(let bar = closure bar_0 @bar in
 let map_foo = closure map_foo_4 @map_foo with { bar = bar } in
 let Pmakeblock = %Block 0 (bar, map_foo) in
 cont k (Pmakeblock))
  where k define_root_symbol (module_block) =
    let field_0 = %block_load tag(0) size(2) (module_block, 0) in
    let field_1 = %block_load tag(0) size(2) (module_block, 1) in
    let $camlTests13 = Block 0 (field_0, field_1) in
    cont done ($camlTests13)
===>
let code
     `anon-fn[:22,44--59]_2`
     deleted
in
let code
     `anon-fn[:22,31--43]_3`
     deleted
in
let code
     `anon-fn[:19,2--118]_1`
     deleted
in
let code bar_0 deleted in
let code
     `anon-fn[:33,15--28]_5`
     deleted
in
let code map_foo_4 deleted in
let code size(1) newer_version_of(`anon-fn[:22,31--43]_3`)
      `anon-fn[:22,31--43]_3_1`
        (x)
        my_closure my_region my_depth
        -> k * k1 =
  cont k (x)
in
let $`camlTests13__anon-fn[:22,31--43]_8` =
  closure
    `anon-fn[:22,31--43]_3_1`
    @`anon-fn[:22,31--43]`
in
let code size(1) newer_version_of(`anon-fn[:22,44--59]_2`)
      `anon-fn[:22,44--59]_2_1`
        (param : imm tagged)
        my_closure my_region my_depth
        -> k * k1
        : variant =
  cont k (0)
in
let $`camlTests13__anon-fn[:22,44--59]_7` =
  closure
    `anon-fn[:22,44--59]_2_1`
    @`anon-fn[:22,44--59]`
in
let code size(10) newer_version_of(`anon-fn[:19,2--118]_1`)
      `anon-fn[:19,2--118]_1_1`
        (param : imm tagged)
        my_closure my_region my_depth
        -> k * k1 =
  let map_foo =
    %project_value_slot
      `anon-fn[:19,2--118]`.map_foo my_closure
  in
  let i =
    %project_value_slot
      `anon-fn[:19,2--118]`.i my_closure
  in
  let j = i + 3 in
  let ignore = %Opaque j in
  apply inlined(never)
    map_foo
      ($`camlTests13__anon-fn[:22,31--43]_8`,
       $`camlTests13__anon-fn[:22,44--59]_7`,
       0)
      -> k * k1
in
let code inline(always) size(20) newer_version_of(bar_0)
      bar_0_1 (i : imm tagged, map_foo)
        my_closure my_region my_depth
        -> k * k1 =
  let `anon-fn[:19,2--118]` =
    closure
      `anon-fn[:19,2--118]_1_1`
      @`anon-fn[:19,2--118]`
  with { i = i; map_foo = map_foo }
  in
  cont k
         (`anon-fn[:19,2--118]`)
in
let $camlTests13__bar_6 = closure bar_0_1 @bar in
let code size(1) newer_version_of(`anon-fn[:33,15--28]_5`)
      `anon-fn[:33,15--28]_5_1`
        (param : imm tagged)
        my_closure my_region my_depth
        -> k * k1
        : variant =
  cont k (0)
in
let $`camlTests13__anon-fn[:33,15--28]_10` =
  closure
    `anon-fn[:33,15--28]_5_1`
    @`anon-fn[:33,15--28]`
in
let code rec size(77) newer_version_of(map_foo_4)
      map_foo_4_1 (f, seq, param : imm tagged)
        my_closure my_region my_depth
        -> k * k1
        : variant =
  apply seq (0) -> k2 * k1
    where k2 (`*match*`) =
      let prim = %is_int `*match*` in
      (switch prim
         | 0 -> k2
         | 1 -> k (0)
         where k2 =
           ((let Popaque = %Opaque 0 in
             (let untagged = %untag_imm Popaque in
              switch untagged
                | 0 -> k3
                | 1 -> k4)
               where k4 =
                 let `anon-fn[:19,2--118]` =
                   closure
                     `anon-fn[:19,2--118]_1_3`
                     @`anon-fn[:19,2--118]`
                 with {
                   i = 10;
                   map_foo =
                     $camlTests13__map_foo_9 ~ depth my_depth -> succ my_depth
                 }
                 in
                 cont k2
                        (`anon-fn[:19,2--118]`)
               where k3 =
                 let `anon-fn[:19,2--118]` =
                   closure
                     `anon-fn[:19,2--118]_1_2`
                     @`anon-fn[:19,2--118]`
                 with {
                   i = 20;
                   map_foo =
                     $camlTests13__map_foo_9 ~ depth my_depth -> succ my_depth
                 }
                 in
                 cont k2
                        (`anon-fn[:19,2--118]`))
              where k2 (g) =
                (apply inlined(always) g (0) -> k2 * k1
                   where k2 (g_result : variant) =
                     let ignore = %Opaque g_result in
                     ((let Pfield = %block_load (`*match*`, 0) in
                       apply f (Pfield) -> k2 * k1)
                        where k2 (apply_result) =
                          let Pmakeblock =
                            %Block 0
                              (apply_result,
                               $`camlTests13__anon-fn[:33,15--28]_10`)
                          in
                          cont k (Pmakeblock)))))
and code size(4) newer_version_of(`anon-fn[:19,2--118]_1_1`)
      `anon-fn[:19,2--118]_1_2`
        (param : imm tagged)
        my_closure my_region my_depth
        -> k * k1 =
  let ignore = %Opaque 23 in
  apply direct(map_foo_4_1) inlined(never) inlining_state(depth(1))
    ($camlTests13__map_foo_9 : _ -> variant)
      ($`camlTests13__anon-fn[:22,31--43]_8`,
       $`camlTests13__anon-fn[:22,44--59]_7`,
       0)
      -> k * k1
and $camlTests13__map_foo_9 =
  closure map_foo_4_1 @map_foo
and code size(4) newer_version_of(`anon-fn[:19,2--118]_1_1`)
      `anon-fn[:19,2--118]_1_3`
        (param : imm tagged)
        my_closure my_region my_depth
        -> k * k1 =
  let ignore = %Opaque 13 in
  apply direct(map_foo_4_1) inlined(never) inlining_state(depth(1))
    ($camlTests13__map_foo_9 : _ -> variant)
      ($`camlTests13__anon-fn[:22,31--43]_8`,
       $`camlTests13__anon-fn[:22,44--59]_7`,
       0)
      -> k * k1
in
let $camlTests13 = Block 0 ($camlTests13__bar_6, $camlTests13__map_foo_9) in
cont done ($camlTests13)
