let $camlTests13__first_const74 = Block 0 () in
let code rec size(82) map_foo_4 (f, seq, param) my_closure my_region
                        my_depth -> k * k1 =
  let next_depth = rec_info (succ my_depth) in
  let bar = %project_value_slot map_foo.bar_2 my_closure in
  apply seq (0) &my_region -> k2 * k1
    where k2 (`*match*`) =
      ((let prim = %is_int `*match*` in
        let is_scrutinee_int = %Tag_imm prim in
        let untagged = %untag_imm is_scrutinee_int in
        switch untagged
          | 0 -> k3
          | 1 -> k4)
         where k4 =
           let untagged = %untag_imm `*match*` in
           cont k (0)
         where k3 =
           let prim = %get_tag `*match*` in
           let scrutinee_tag = %Tag_imm prim in
           let untagged = %untag_imm scrutinee_tag in
           cont k2
         where k2 =
           ((let Popaque = %Opaque 0 in
             (let untagged = %untag_imm Popaque in
              switch untagged
                | 0 -> k3
                | 1 -> k4)
               where k4 =
                 apply
                   bar
                   (10, my_closure ~ depth my_depth -> next_depth) &my_region
                   -> k2 * k1
               where k3 =
                 apply
                   bar
                   (20, my_closure ~ depth my_depth -> next_depth) &my_region
                   -> k2 * k1)
              where k2 (g) =
                (apply g (0) &my_region -> k2 * k1
                   where k2 (g_result) =
                     ((let ignore = %Opaque g_result in
                       cont k2 (0))
                        where k2 (sequence) =
                          let `anon-fn[tests13.ml:29,15--28]` =
                            closure `anon-fn[tests13.ml:29,15--28]_5`
                              @`anon-fn[tests13.ml:29,15--28]`
                          in
                          let Pfield = %block_load tag(0) size(2) (`*match*`, 0)
                          in
                          (apply f (Pfield) &my_region -> k2 * k1
                             where k2 (apply_result) =
                               let Pmakeblock =
                                 %Block 0
                                   (apply_result,
                                    `anon-fn[tests13.ml:29,15--28]`)
                               in
                               cont k (Pmakeblock))))))
in
let code inline(always) size(37) bar_0 (i : imm tagged, map_foo) my_closure my_region
                                   my_depth -> k * k1 =
  let next_depth = rec_info (succ my_depth) in
  let `anon-fn[tests13.ml:16,2--118]` =
    closure `anon-fn[tests13.ml:16,2--118]_1`
      @`anon-fn[tests13.ml:16,2--118]`
  with { i_0 = i; map_foo_1 = map_foo }
  in
  cont k (`anon-fn[tests13.ml:16,2--118]`)
in
let code size(1) `anon-fn[tests13.ml:19,44--59]_2` (param : imm tagged)
                   my_closure my_region my_depth -> k * k1 =
  let next_depth = rec_info (succ my_depth) in
  cont k (0)
in
let code size(27) `anon-fn[tests13.ml:16,2--118]_1` (param : imm tagged)
                    my_closure my_region my_depth -> k * k1 =
  let next_depth = rec_info (succ my_depth) in
  let map_foo =
    %project_value_slot `anon-fn[tests13.ml:16,2--118]`.map_foo_1 my_closure
  in
  let i = %project_value_slot `anon-fn[tests13.ml:16,2--118]`.i_0 my_closure in
  let j = i + 3 in
  (let ignore = %Opaque j in
   cont k2 (0))
    where k2 (sequence) =
      let `anon-fn[tests13.ml:19,44--59]` =
        closure `anon-fn[tests13.ml:19,44--59]_2`
          @`anon-fn[tests13.ml:19,44--59]`
      in
      let `anon-fn[tests13.ml:19,31--43]` =
        closure `anon-fn[tests13.ml:19,31--43]_3`
          @`anon-fn[tests13.ml:19,31--43]`
      in
      apply map_foo
        (`anon-fn[tests13.ml:19,31--43]`, `anon-fn[tests13.ml:19,44--59]`, 0) &my_region
        -> k * k1
in
let code size(1) `anon-fn[tests13.ml:19,31--43]_3` (x) my_closure my_region my_depth
                   -> k * k1 =
  let next_depth = rec_info (succ my_depth) in
  cont k (x)
in
let code size(1) `anon-fn[tests13.ml:29,15--28]_5` (param : imm tagged)
                   my_closure my_region my_depth -> k * k1 =
  let next_depth = rec_info (succ my_depth) in
  cont k (0)
in
(let bar = closure bar_0 @bar in
 let map_foo = closure map_foo_4 @map_foo with { bar_2 = bar } in
 let Pmakeblock = %Block 0 (map_foo) in
 cont k (Pmakeblock))
  where k define_root_symbol (module_block) =
    let field_0 = %block_load tag(0) size(1) (module_block, 0) in
    let $camlTests13 = Block 0 (field_0) in
    cont done ($camlTests13)
