(* external sys_exit : int -> 'a = "caml_sys_exit" *)
(* let f = (fun x -> x) *)
let exit_function = CamlinternalAtomic.make Sys.opaque_identity
let rec at_exit f =
  let module Atomic = CamlinternalAtomic in
  (* MPR#7253, MPR#7796: make sure "f" is executed only once *)
  let f_yet_to_run = Atomic.make true in
  let old_exit = Atomic.get exit_function in
  let new_exit () =
    if Atomic.compare_and_set f_yet_to_run true false then f () ;
    old_exit ()
  in
  let success = Atomic.compare_and_set exit_function old_exit new_exit in
  if success then at_exit f

external major : unit -> unit = "caml_gc_major"
external naked_pointers_checked : unit -> bool
  = "caml_sys_const_naked_pointers_checked"
let () = if naked_pointers_checked () then at_exit major

let () = at_exit major
